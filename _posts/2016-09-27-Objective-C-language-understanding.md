---
layout: post
title:  Learning Notes - Objective-C language semantic understanding
---

## Understanding ObjC Objects and Messaging
- Objects are building blocks of programming in an object-oriented language,providing the means by which data is stored and moved around. Objects是面向对象语言中编程的构建块，提供方式以便数据存储和移动。
- Messaging is the process by which objects talk to each other to move data around and make things happen. 消息处理对象沟通以移动数据并且做一些事情。
- The rumtime provides crucial functions that enable messaging between objects to work and all the logic behind how instances of classes are created.

## Properties
- Properties are an Objective-C feature providing encapsulation of the data an object contains.  属性用于封装对象的数据
- Properties 是 Objective－C 2.0 对传统 accessor 方法的标准化
- 传统 accessor 方法在 Objective－C 中的问题在于，对象的布局是在编译阶段完成的。编译器一般会对 instance variables 在存储数据的内存区域中进行硬编码偏移量。如果在原来第一个 instance variable 位置之前再插入一个 instance variable，那么原来第一个变量指针的位置会被后插入的占用，其余的依次后移。因而一些硬编码方法偏移的代码将会无法工作。
- Objective-C 2.0通过no fragile Application Binary Interface(ABI)来解决上面的问题，在运行时，instance variables 的偏移会被监控，如果有变化，那么偏移（offset）会被更新。
- ABI定义了代码生成的方式，no fragile ABI 意味着instance variables可以在Category（class－continuation）甚至implementation 中定义。这样就可以不在public interface中泄漏所有的内部数据信息。
- Properties的accessor相关部分会自动合成autosynthesis，如果想控制instance variable的命名，使用@sythesize 语法。
- @dynamic关键字告诉编译器不要自动生成instance variable和accessor方法。当编译对应的属性访问代码时，编译器将会忽略accessor方法可能不存在的事实，而总是信任你将会在运行时提供相应的accessor。

## Property(特性，财产) attributes（属性）
You shoule be aware of all the attributes of property that can be used to control the accessor generated by compiler。

Remember:

1. the @property syntax provides a way of defining what data an object encapsulates
2. use *_noatomic_* in iOS , since performance is severely be impacted if **atomic** keyword is used.
3. Any Object that can be mutated should take a *copy*
4. 

### Memory-Management Semantics
Properties encapsulated data,and that data needs to have concrete ownership smantics.**This affects only the setter**.内存相关的attributes只施加于setter。

### readonly/readwrite
- readonly 仅有getter可用，sythensize时仅生成getter方法。A technique here,you may want to use this if you expose a property for read externally but redeclare it read/write internally in the class-continuation cagegory. 外部曝露只读property，但在category中重新声明为内部读写。

## Access Instance Variables Primarily Directly When Accessing Them Internally
在内部访问（主要是只读访问）实例变量时，直接访问实例变量。如果涉及setter，那最好还是使用accessor方法。







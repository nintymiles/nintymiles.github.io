<!DOCTYPE html>
<html lang="en-us">

  <head>
  <link href="http://gmpg.org/xfn/11" rel="profile">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta http-equiv="content-type" content="text/html; charset=utf-8">

  <!-- Enable responsiveness on mobile devices-->
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1">

  <title>
    
      Learning notes &middot; 九十里
    
  </title>

  <!-- CSS -->
  <link rel="stylesheet" href="/public/css/poole.css">
  <link rel="stylesheet" href="/public/css/syntax.css">
  <link rel="stylesheet" href="/public/css/lanyon.css">
  <link rel="stylesheet" href="https://fonts.googleapis.com/css?family=PT+Serif:400,400italic,700%7CPT+Sans:400">

  <!-- Icons -->
  <link rel="apple-touch-icon-precomposed" sizes="144x144" href="/public/apple-touch-icon-precomposed.png">
  <link rel="shortcut icon" href="/public/favicon.ico">

  <!-- RSS -->
  <link rel="alternate" type="application/rss+xml" title="RSS" href="/atom.xml">
</head>


  <body>

    <!-- Target for toggling the sidebar `.sidebar-checkbox` is for regular
     styles, `#sidebar-checkbox` for behavior. -->
<input type="checkbox" class="sidebar-checkbox" id="sidebar-checkbox">

<!-- Toggleable sidebar -->
<div class="sidebar" id="sidebar">
  <div class="sidebar-item">
    <p>我在故我思，我思故我在</p>
  </div>

  <nav class="sidebar-nav">
    <a class="sidebar-nav-item" href="/">Home</a>

    

    
    
      
         
        	
        
      
    
      
         
        	
        
      
    
      
         
      
    
      
         
        	
          	<a class="sidebar-nav-item" href="/archive/">Archive</a>
        	
        
      
    
      
    
      
         
        	
        
      
    
      
         
        	
        
      
    
      
         
        	
        
      
    
      
         
        	
        
      
    
      
         
        	
        
      
    
      
         
        	
        
      
    

    <!--<a class="sidebar-nav-item" href="/archive/v1.0.0.zip">Download</a>
    <a class="sidebar-nav-item" href="">GitHub project</a>-->
    <a class="sidebar-nav-item" href="/about">About</a>
    <span class="sidebar-nav-item">Currently v1.0.0</span>
  </nav>

  <div class="sidebar-item">
    <p>
      &copy; 2016. All rights reserved.
    </p>
  </div>
</div>


    <!-- Wrap is the content to shift when toggling the sidebar. We wrap the
         content to avoid any CSS collisions with our real content. -->
    <div class="wrap">
      <div class="masthead">
        <div class="container">
          <h3 class="masthead-title">
            <a href="/" title="Home">九十里</a>
            <small>行百里者半九十</small>
          </h3>
        </div>
      </div>

      <div class="container content">
        <div class="post">
  <h1 class="post-title">Learning notes</h1>
  <span class="post-date">07 Jun 2016</span>
  <h2 id="section">计数排序的理解</h2>
<ol>
  <li>先找出数组中的最大元素，然后以最大元素值加1建立计数数组</li>
  <li>将实际元素在计数数组作为索引值，并将此位置存储出现次数计数</li>
  <li>把从头到尾的索引值的出现次数相加，然后得到每个元素的其实际索引位置。最后在1:1的新数组中将是实际值赋值到实际索引位置。</li>
  <li>因为实际计数每个数值的出现都计算在内，而数组索引从零开始，所以计算出的索引值实际使用时都要减1？</li>
</ol>

<h2 id="counting-sort">Counting sort</h2>
<p>To understand the algorithm let’s walk through a small example.</p>

<p>Consider the array: <code class="highlighter-rouge">[ 10, 9, 8, 7, 1, 2, 7, 3 ]</code></p>

<h3 id="step-1">Step 1:</h3>

<p>The first step is to count the total number of occurrences for each item in the array. The output for the first step would be a new array that looks as follows:</p>

<div class="highlighter-rouge"><pre class="highlight"><code>Index 0 1 2 3 4 5 6 7 8 9 10
</code></pre>
</div>

<p>Here is the code to accomplish this:</p>

<div class="highlighter-rouge"><pre class="highlight"><code>  <span class="k">let</span> <span class="nv">maxElement</span> <span class="o">=</span> <span class="n">array</span><span class="o">.</span><span class="nf">maxElement</span><span class="p">()</span> <span class="p">??</span> <span class="mi">0</span>
  
  <span class="k">var</span> <span class="nv">countArray</span> <span class="o">=</span> <span class="err">\</span><span class="p">[</span><span class="kt">Int</span><span class="p">](</span><span class="nv">count</span><span class="p">:</span> <span class="kt">Int</span><span class="p">(</span><span class="n">maxElement</span> <span class="o">+</span> <span class="mi">1</span><span class="p">),</span> <span class="nv">repeatedValue</span><span class="p">:</span> <span class="mi">0</span><span class="p">)</span>
  <span class="k">for</span> <span class="n">element</span> <span class="k">in</span> <span class="n">array</span> <span class="p">{</span>
     <span class="n">countArray</span><span class="p">[</span><span class="n">element</span><span class="p">]</span> <span class="o">+=</span> <span class="mi">1</span>
  <span class="p">}</span>
</code></pre>
</div>

<h3 id="step-2">Step 2:</h3>

<p>In this step the algorithm tries to determine the number of elements that are placed before each element. Since, you already know the total occurrences for each element you can use this information to your advantage. The way it works is to sum up the previous counts and store them at each index.</p>

<p>The count array would be as follows:</p>

<div class="highlighter-rouge"><pre class="highlight"><code>Index 0 1 2 3 4 5 6 7 8 9 10
Count 0 1 2 3 3 3 3 5 6 7 8
</code></pre>
</div>

<p>The code for step 2 is:</p>

<div class="highlighter-rouge"><pre class="highlight"><code>  <span class="k">for</span> <span class="n">index</span> <span class="k">in</span> <span class="mi">1</span> <span class="o">..&lt;</span> <span class="n">countArray</span><span class="o">.</span><span class="n">count</span> <span class="p">{</span>
    <span class="k">let</span> <span class="nv">sum</span> <span class="o">=</span> <span class="n">countArray</span><span class="p">[</span><span class="n">index</span><span class="p">]</span> <span class="o">+</span> <span class="n">countArray</span><span class="p">[</span><span class="n">index</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span>
    <span class="n">countArray</span><span class="p">[</span><span class="n">index</span><span class="p">]</span> <span class="o">=</span> <span class="n">sum</span>
  <span class="p">}</span>
</code></pre>
</div>

<h3 id="step-3">Step 3:</h3>

<p>This is the last step in the algorithm. Each element in the original array is placed at the position defined by the output of step 2. For example, the number 10 would be placed at an index of 7 in the output array. Also, as you place the elements you need to reduce the count by 1 as those many elements are reduced from the array.</p>

<p>The final output would be:</p>

<div class="highlighter-rouge"><pre class="highlight"><code>Index  0 1 2 3 4 5 6 7
Output 1 2 3 7 7 8 9 10
</code></pre>
</div>

<p>Here is the code for this final step:</p>

<div class="highlighter-rouge"><pre class="highlight"><code><span class="k">var</span> <span class="nv">sortedArray</span> <span class="o">=</span> <span class="err">\</span><span class="p">[</span><span class="kt">Int</span><span class="p">](</span><span class="nv">count</span><span class="p">:</span> <span class="n">array</span><span class="o">.</span><span class="n">count</span><span class="p">,</span> <span class="nv">repeatedValue</span><span class="p">:</span> <span class="mi">0</span><span class="p">)</span>
  <span class="k">for</span> <span class="n">element</span> <span class="k">in</span> <span class="n">array</span> <span class="p">{</span>
    <span class="n">countArray</span><span class="p">[</span><span class="n">element</span><span class="p">]</span> <span class="o">-=</span> <span class="mi">1</span>
    <span class="n">sortedArray</span><span class="p">[</span><span class="n">countArray</span><span class="p">[</span><span class="n">element</span><span class="p">]]</span> <span class="o">=</span> <span class="n">element</span>
  <span class="p">}</span>
  <span class="k">return</span> <span class="n">sortedArray</span>
</code></pre>
</div>

<h2 id="performance">Performance</h2>

<p>The algorithm uses simple loops to sort a collection. Hence, the time to run the entire algorithm is <strong>O(n+k)</strong> where <strong>O(n)</strong> represents the loops that are required to initialize the output arrays and <strong>O(k)</strong> is the loop required to create the count array.</p>

<p>The algorithm uses arrays of length <strong>n + 1</strong> and <strong>n</strong>, so the total space required is <strong>O(2n)</strong>. Hence for collections where the keys are scattered in a dense area along the number line it can be space efficient.</p>

</div>

<div class="related">
  <h2>Related Posts</h2>
  <ul class="related-posts">
    
      <li>
        <h3>
          <a href="/2016/06/04/reading-notes/">
            Reading notes
            <small>04 Jun 2016</small>
          </a>
        </h3>
      </li>
    
      <li>
        <h3>
          <a href="/2016/06/04/forward-article-elephant-in-room/">
            房间里的大象
            <small>04 Jun 2016</small>
          </a>
        </h3>
      </li>
    
      <li>
        <h3>
          <a href="/2016/06/03/x-reading-notes/">
            Reading notes
            <small>03 Jun 2016</small>
          </a>
        </h3>
      </li>
    
  </ul>
</div>

      </div>
    </div>

    <label for="sidebar-checkbox" class="sidebar-toggle"></label>

    <script>
      (function(document) {
        var toggle = document.querySelector('.sidebar-toggle');
        var sidebar = document.querySelector('#sidebar');
        var checkbox = document.querySelector('#sidebar-checkbox');

        document.addEventListener('click', function(e) {
          var target = e.target;

          if(!checkbox.checked ||
             sidebar.contains(target) ||
             (target === checkbox || target === toggle)) return;

          checkbox.checked = false;
        }, false);
      })(document);
    </script>
  </body>
</html>
